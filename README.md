目录结构说明
BoundedContextName(限界上下文名字)
--application(应用服务)
----command(应用命令)
----listener(监听事件)
--domain(领域对象)
----event(领域事件)
----exception(领域异常)
----model(领域模型)
------aggregate(聚合根)
------valueObject(值对象)
----service(领域服务)
--infrastructure(基建)
----acl(防腐层)
----repository(持久化层)
--interface(独立外部接口)
----grpc
----rest
----web

最外层公共部分应该pom引入

请求处理过程
路由：进行参数处理和结果的结构处理 直接把参数传递给限界上下文 不论是否设计多个限界上下文都是只调用一个限界上下文

限界上下文 不是代码里的一个类，而是你设计系统时的“思维边界”

应用服务：限界上下文的实际存在形态 是编排层 创建聚合根（屏蔽数据底层） 调用领域服务（会有多个聚合根参数） 调用防腐层（使用外部sdk-api）
聚合根的持久化、事务管理 消息的发布

领域服务: 实现跨聚合根复杂逻辑的地方 无状态的 纯逻辑 没有任何其他的东西 

聚合根：包含值对象、原子化方法（会保存事件）最形象的比喻就像是在操作一条数据

与传统4层架构进行对比
内聚性很强 不论是数据自己的行为 还是某个业务的行为 都很集中不会有不统一的存在 修改的范围和能力都是可控的
不同的域就像是不同的服务一样 很适合微服务架构 无论如何迭代项目都不会更加的复杂了
代价是 各种交互变多原来是直接注入使用现在是rest、grpc 各种对象变多 代码量增加
本地事务被摄取 换来了边界和秩序 我们需要自己去解决事务问题 saga中央协调者就挺好
A 完成本地事务 发送完成消息给 manager
B 完成本地事务 发送完成消息给 manager
C 完成本地事务 发送完成消息给 manager
manager 接收到的第一条为定时器开启时机 如果时间内完成不做处理 未完成 就发送ABC回滚消息

哪些风险
难点是在于如何划分、多方如何对一个语义保持一致、技术上还是有迹可循的。
